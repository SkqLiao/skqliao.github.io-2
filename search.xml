<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「2020 EC Final」D. City Brain</title>
    <url>/2021/08/31/2020-EC-Final-D/</url>
    <content><![CDATA[<h2 id="「题意」"><a href="#「题意」" class="headerlink" title="「题意」"></a>「题意」</h2><p>给定一个 $n$ 个点 $m$ 条边的无向图，初始边权都是 $1$，给定两组起点和终点 $(s_1,t_1)$ 和 $(s_2,t_2)$ 。</p>
<p>现在有 $k$ 次机会，每次可以令某条边的边权 $+1$。通过一条边的时间为其边权的倒数，求 $\min{dis(s_1,t_1)+dis(s_2,t_2)}$。</p>
<p>$n,m\leq 5000, k\leq 10^9$</p>
<h3 id="「题目链接」"><a href="#「题目链接」" class="headerlink" title="「题目链接」"></a>「题目链接」</h3><p><a href="https://codeforces.com/gym/103069/problem/D">D - City Brain</a></p>
<h2 id="「分析」"><a href="#「分析」" class="headerlink" title="「分析」"></a>「分析」</h2><p> $(s_1,t_1)$ 和 $(s_2,t_2)$ 的两条路径可能存在交集，而修改交集上的边权会同时影响两条路径的时间，修改非交集的边则只会影响某一条路径的时间。</p>
<p>由于二者的贡献不同，我们要分开考虑。</p>
<p>鉴于原图是个很小的无权图，我们可以做 $n$ 次BFS， $O(nm)$ 求出任意两点间的最短距离。</p>
<p>然后可以枚举两路径相交部分的起点和终点，用 $O(n^2)$ 的复杂度算出两路径相交部分的长度为 $0\sim n-1$ 时，不相交部分的最短长度。</p>
<p>现在考虑，当相交路径和不相交路径的长度确定时，如何分配这 $k$ 次操作会使得答案最优。</p>
<p>假设两路径相交部分的长度为 $a$，不相交部分的长度为 $b$，将 $x$ 次操作分配给相交部分，则 $k-x$ 次操作分配给不相交部分。</p>
<p>显然平均分配给每条边会使得答案最优，最终的答案为<br>$$<br>f_{k,a,b}(x)=\frac{x\bmod a}{2 + \lfloor{\frac{x}{a}}\rfloor}+\frac{a-x\bmod a}{1 + \lfloor{\frac{x}{a}}\rfloor}+\frac{(k-x)\bmod b}{2 + \lfloor{\frac{k-x}{b}}\rfloor}+\frac{b-(k-x)\bmod b}{1 + \lfloor{\frac{k-x}{b}}\rfloor}<br>$$<br>这是个凸函数，因此可以用三分的方法取出它的最小值。</p>
<p>$a$ 只有 $0\sim n-1$ 这 $n$ 种情况，对于每个 $a$ 都预处理出了最小的 $b$ ，因此可以对于每个 $(a,b)$ 都求出它对应的最小值，答案就是所有情况的最小值。</p>
<p>复杂度 $O(nm+n\log{k})$。</p>
<h2 id="「参考代码」"><a href="#「参考代码」" class="headerlink" title="「参考代码」"></a>「参考代码」</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> up(i, l, r) for (int i = l; i &lt;= r; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dn(i, l, r) for (int i = l; i &gt;= r; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Trav(i, x) for (auto &amp; i : x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMax</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &gt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMin</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &lt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> s1, t1, s2, t2;</span><br><span class="line"><span class="keyword">int</span> Mn[N];</span><br><span class="line"><span class="keyword">int</span> Dis[N][N];</span><br><span class="line">vi g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> Dis[])</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    Dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">Trav</span>(v, g[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">chkMin</span>(Dis[v], Dis[x] + <span class="number">1</span>)) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!num) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (total % num) / (<span class="number">2</span> + total / num) + <span class="number">1.0</span> * (num - total % num) / (<span class="number">1</span> + total / num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">cal</span>(a, p) + <span class="built_in">cal</span>(b, k - p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = k;</span><br><span class="line">    <span class="keyword">double</span> lans = <span class="number">0</span>, rans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> lmid = l + (r - l) / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> rmid = r - (r - l) / <span class="number">3</span>;</span><br><span class="line">        lans = <span class="built_in">f</span>(a, b, lmid), rans = <span class="built_in">f</span>(a, b, rmid);</span><br><span class="line">        <span class="keyword">if</span> (lans &lt;= rans) r = rmid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = lmid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(lans, rans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) g[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        g[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; t1 &gt;&gt; s2 &gt;&gt; t2;</span><br><span class="line">    <span class="built_in">memset</span>(Dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> Dis);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">bfs</span>(i, Dis[i]);</span><br><span class="line">    <span class="built_in">memset</span>(Mn, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> Mn);</span><br><span class="line">    Mn[<span class="number">0</span>] = Dis[s1][t1] + Dis[s2][t2];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Dis[i][j] &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> d1 = Dis[i][s1] + Dis[j][t1];</span><br><span class="line">            <span class="keyword">int</span> d2 = Dis[i][t1] + Dis[j][s1];</span><br><span class="line">            <span class="keyword">int</span> d3 = Dis[i][s2] + Dis[j][t2];</span><br><span class="line">            <span class="keyword">int</span> d4 = Dis[i][t2] + Dis[j][s2];</span><br><span class="line">            <span class="keyword">if</span> (d1 &gt; n &amp;&amp; d2 &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (d3 &gt; n &amp;&amp; d4 &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">chkMin</span>(Mn[Dis[i][j]], <span class="built_in">min</span>(d1, d2) + <span class="built_in">min</span>(d3, d4));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">chkMin</span>(ans, <span class="built_in">get</span>(i, Mn[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>2020 ICPC Asia East Continent Final</category>
      </categories>
      <tags>
        <tag>三分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>「HDU Multi 2021」[HDU 7075] Unfair contest</title>
    <url>/2021/08/23/HDU-7075/</url>
    <content><![CDATA[<h2 id="「题意」"><a href="#「题意」" class="headerlink" title="「题意」"></a>「题意」</h2><p>给定两个长为 $n-1$ 的序列 $a$ 和 $b$，以及三个正整数 $s,t,h$。现在可以给 $a,b$ 分别插入一个正整数 $a_n$ 和 $b_n$（要求范围在 $[1,h]$），补成 $n$ 个数。</p>
<p>定义一个序列的权值为删去最小的 $s$ 个数和最大的 $t$ 个数后，剩余 $n-s-t$ 个数之和。</p>
<p>现要求 $a$ 的权值要严格大于 $b$ 的权值，求 $\max(a_n-b_n)$，若无解则输出<code>IMPOSSIBLE</code>。</p>
<p>$\sum{n}\leq 10^6,h\leq 10^9$</p>
<h3 id="「链接」"><a href="#「链接」" class="headerlink" title="「链接」"></a>「链接」</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7075">7075</a></p>
<h2 id="「分析」"><a href="#「分析」" class="headerlink" title="「分析」"></a>「分析」</h2><p>$a_n$ 和 $b_n$ 共有 $9$ 类情况，分别是被作为较小值删除、被保留和被作为较大值删除，分别讨论即可。</p>
<p>复杂度 $O(n\log{n})$。</p>
<h2 id="「参考代码」"><a href="#「参考代码」" class="headerlink" title="「参考代码」"></a>「参考代码」</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @date:</span></span><br><span class="line"><span class="comment"> * @source:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> up(i, l, r) for (int i = l; i &lt;= r; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dn(i, l, r) for (int i = l; i &gt;= r; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Trav(i, x) for (auto &amp; i : x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMax</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &gt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMin</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &lt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, s, t, h;</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; s &gt;&gt; t &gt;&gt; h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) cin &gt;&gt; A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) cin &gt;&gt; B[i];</span><br><span class="line">    <span class="built_in">sort</span>(A + <span class="number">1</span>, A + N);</span><br><span class="line">    <span class="built_in">sort</span>(B + <span class="number">1</span>, B + N);</span><br><span class="line">    ll suma1 = <span class="number">0</span>, suma2 = <span class="number">0</span>, sumb1 = <span class="number">0</span>, sumb2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= N - s - <span class="number">1</span>; ++i) &#123; <span class="comment">// erase left max&#123;a&#125; = A[t] min&#123;a&#125; = 1</span></span><br><span class="line">        suma1 += A[i];</span><br><span class="line">        sumb1 += B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t + <span class="number">1</span>; i &lt;= N - s; ++i) &#123; <span class="comment">// erase right max&#123;a&#125; = h min&#123;a&#125; = A[N - s]</span></span><br><span class="line">        suma2 += A[i];</span><br><span class="line">        sumb2 += B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">if</span> (suma1 &gt; sumb1 &amp;&amp; t) &#123;</span><br><span class="line">        <span class="built_in">chkMin</span>(ans, <span class="number">1</span> - B[t]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (suma1 &gt; sumb2 &amp;&amp; s &amp;&amp; t) &#123;</span><br><span class="line">        <span class="built_in">chkMin</span>(ans, <span class="number">1</span> - h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (suma2 &gt; sumb1 &amp;&amp; s &amp;&amp; t) &#123;</span><br><span class="line">        <span class="built_in">chkMin</span>(ans, A[N - s] - B[t]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (suma2 &gt; sumb2 &amp;&amp; s) &#123;</span><br><span class="line">        <span class="built_in">chkMin</span>(ans, A[N - s] - h);</span><br><span class="line">    &#125;</span><br><span class="line">    ll suma3 = <span class="number">0</span>, sumb3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t + <span class="number">1</span>; i &lt; N - s; ++i) &#123;</span><br><span class="line">        suma3 += A[i];</span><br><span class="line">        sumb3 += B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;pre&quot; &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">        A[<span class="number">0</span>] = <span class="number">1</span>, B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">        A[N] = h, B[N] = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= N - s; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = suma3 + A[i] - sumb3 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((t &amp;&amp; tmp &lt; B[t]) || (!t &amp;&amp; tmp &lt; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">chkMax</span>(tmp, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">chkMin</span>(ans, A[i] - <span class="built_in">min</span>(tmp, B[N - s]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= N - s; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = sumb3 + B[i] - suma3 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((s &amp;&amp; tmp &gt; A[N - s]) || (!s &amp;&amp; tmp &gt; h)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">chkMax</span>(tmp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">chkMin</span>(ans, tmp - B[i])) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; tmp &lt;&lt; &quot; &quot; &lt;&lt; B[i] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = suma1 - sumb3 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= B[t] || (!t &amp;&amp; x &gt;= <span class="number">1</span>)) <span class="built_in">chkMin</span>(ans, <span class="number">1</span> - <span class="built_in">min</span>(B[N - s], x));</span><br><span class="line">        <span class="keyword">int</span> y = sumb1 - suma3 + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">chkMax</span>(y, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= A[N - s]) <span class="built_in">chkMin</span>(ans, y - B[t]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = suma2 - sumb3 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= B[t] || (!t &amp;&amp; x &gt;= <span class="number">1</span>)) <span class="built_in">chkMin</span>(ans, A[N - s] - <span class="built_in">min</span>(B[N - s], x));</span><br><span class="line">        <span class="keyword">int</span> y = sumb2 - suma3 + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">chkMax</span>(y, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= A[N - s]) <span class="built_in">chkMin</span>(ans, y - h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == INT_MAX) cout &lt;&lt; <span class="string">&quot;IMPOSSIBLE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> Case;</span><br><span class="line">    cin &gt;&gt; Case;</span><br><span class="line">    <span class="keyword">while</span> (Case--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HDU 多校</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>「HDU 2021 Multi 9」[HDU 7073] Integers Have Friends 2.0</title>
    <url>/2021/08/20/HDU-7073/</url>
    <content><![CDATA[<h2 id="「题意」"><a href="#「题意」" class="headerlink" title="「题意」"></a>「题意」</h2><p>给定一个由 $n$ 个不同正整数组成的数组 $a$，选择一个最长子序列 $a_{c_1},\cdots,a_{c_p}$，使得存在某个正整数 $m$，满足 $a_{c_1}\bmod m=a_{c_2}\bmod m\cdots=a_{c_p}\bmod m$。</p>
<p>$a_i\leq 4\times10^{12},\sum{n}\leq 10^6$</p>
<h3 id="「链接」"><a href="#「链接」" class="headerlink" title="「链接」"></a>「链接」</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7073">7073</a></p>
<h2 id="「分析」"><a href="#「分析」" class="headerlink" title="「分析」"></a>「分析」</h2><p>成功被出题人带到CF1648B（同问题求最长子区间）的坑里去了，总想着要找到同余系的话就要满足任意两个数的差都有大于 $1$ 的公因数，于是就不停在想对这 $n^2$ 对差怎么搞。。。</p>
<p>实际上，答案一定大于 $\lfloor\frac{n}{2}\rfloor$。因为当 $m$ 取 $2$ 时，奇数或偶数肯定有一个会超过一半。</p>
<p>那么，随机选择两个数 $a_x$ 和 $a_y$，他们有超过 $\frac{1}{4}$ 的概率同属于最大的同余系。若想找到与它同属一个同余系的其他数，只需要分别求出 $b_i=|a_i-a_x|$ ，然后判断 $b_i$ 是否存在大于 $1$ 的公因数即可。具体来说，就是对 $|a_x-a_y|$ 分解质因数，然后依次判断 $b_i$ 是否是该质因数的倍数。由于在 $a_i\leq 4\times10^{12}$ 的范围内至多出现 $11$ 个质因数，因此跑一次复杂度为 $O(11n\sqrt{a_i})$。</p>
<p>随机选择 $k$ 次 $(x,y)$，就有$1-\frac{1}{4^k}$ 的概率找到最大的同余系，取 $k=40$ 即可。</p>
<h2 id="「参考代码」"><a href="#「参考代码」" class="headerlink" title="「参考代码」"></a>「参考代码」</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @date:2021-08-17 16:18:59</span></span><br><span class="line"><span class="comment"> * @source:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> up(i, l, r) for (int i = l; i &lt;= r; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dn(i, l, r) for (int i = l; i &gt;= r; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Trav(i, x) for (auto &amp; i : x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMax</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &gt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMin</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &lt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">ll v[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PRIMERANGE = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">bitset&lt;PRIMERANGE&gt; isnPri;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; Prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isnPri[i]) Prime.<span class="built_in">pb</span>(i);</span><br><span class="line">        <span class="built_in">Trav</span>(p, Prime) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = p * i;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            isnPri[x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">divide</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    vector&lt;ll&gt; vs;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = -x;</span><br><span class="line">    <span class="built_in">Trav</span>(p, Prime) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p * p &gt; x) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (x % p == <span class="number">0</span>) &#123;</span><br><span class="line">            vs.<span class="built_in">pb</span>(p);</span><br><span class="line">            <span class="keyword">while</span> (x % p == <span class="number">0</span>) x /= p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) vs.<span class="built_in">pb</span>(x);</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">rand</span>() % N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            B[j] = <span class="built_in">abs</span>(v[a] - v[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;ll&gt; v1 = <span class="built_in">divide</span>(B[a + <span class="built_in">rand</span>() % (N - a)]);</span><br><span class="line">        <span class="built_in">Trav</span>(x, v1) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (B[j] % x == <span class="number">0</span>) ++num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">chkMax</span>(ans, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="number">19260817</span>);</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">Euler</span>(<span class="number">2e6</span>);</span><br><span class="line">    <span class="keyword">int</span> Case;</span><br><span class="line">    cin &gt;&gt; Case;</span><br><span class="line">    <span class="keyword">while</span> (Case--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HDU 多校</category>
      </categories>
      <tags>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>「HDU 2021 Multi 10」[HDU 7074] Pty loves string</title>
    <url>/2021/08/22/HDU-7084/</url>
    <content><![CDATA[<h2 id="「题意」"><a href="#「题意」" class="headerlink" title="「题意」"></a>「题意」</h2><p>给定长为 $n$ 的字符串 $s[1\cdots n]$，有 $m$ 个询问。每次给定 $x,y$，查询由 $s[1,x]$ 和 $s[n-y+1,n]$ 拼接而成的字符串在 $s$ 中的出现次数。</p>
<p>$T\leq 5,n,m\leq 2\times 10^5$</p>
<h3 id="「链接」"><a href="#「链接」" class="headerlink" title="「链接」"></a>「链接」</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7084">7084</a></p>
<h2 id="「分析」"><a href="#「分析」" class="headerlink" title="「分析」"></a>「分析」</h2><p>对于一个出现位置 $s[l,r]$ ，满足 $s[l,l + x − 1]$ 和 $s[1,x]$ 相等， $s[r − y + 1,r]$ 和 $s[n − y + 1,n]$ 相等，且 $l+x-1+1=r-y+1$。</p>
<p>对于 $s[1,l+x-1]$ 来说，这两个相等的部分就是前后缀，这能联想到border。</p>
<p>用KMP预处理，通过跳next，$s[l+x-1]$ 能跳到 $s[x]$。从后往前跑KMP，反着建next，$s[r-y+1]$ 能跳到 $s[n-y+1]$。</p>
<p>因此可以建成正反两棵next树，$i$ 与 $next[i]$ 连边，那么符合条件的便是 $x$ 子树的所有节点。</p>
<p>而由于 $l+x=r-y+1$，因此若两棵子树上的两个点编号差为 $1$，则它们对应的 $[l,r]$ 便是一个出现位置。</p>
<p>问题转化为两棵树，查询在第一棵树中 $x$ 的子树与第二棵树中 $n-y+1$ 的子树中，节点编号差为 $1$ 的点对数量。</p>
<p>这可以转化为二维数点问题。</p>
<p>具体来说，对两棵树求DFS序，并将第一棵树的DFS序（因为节点编号差 $1$，因此整体右移一位）映射到第二棵树上。现在只需要求DFS序在 $[Dfn[y],Dfn[y]+Sz[y]-1]$ 中，权值在 $[Dfn[x],Dfn[x]+Sz[x]-1]$ 中的点个数。</p>
<p>这可以用主席树或者其他一个log的方法解决。</p>
<p>复杂度 $O(m\log{n})$。</p>
<h2 id="「参考代码」"><a href="#「参考代码」" class="headerlink" title="「参考代码」"></a>「参考代码」</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @date:</span></span><br><span class="line"><span class="comment"> * @source:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> up(i, l, r) for (int i = l; i &lt;= r; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dn(i, l, r) for (int i = l; i &gt;= r; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Trav(i, x) for (auto &amp; i : x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMax</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &gt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMin</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &lt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> Nxt[N], Nxt2[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = ::N;</span><br><span class="line">    vi G[N];</span><br><span class="line">    <span class="keyword">int</span> Dfn[N], Nfd[N], Sz[N], tot;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        Dfn[x] = ++tot;</span><br><span class="line">        Nfd[tot] = x;</span><br><span class="line">        Sz[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">Trav</span>(v, G[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(v, x);</span><br><span class="line">            Sz[x] += Sz[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t1, t2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PresidentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = ::N * <span class="number">40</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ls, rs, sum;</span><br><span class="line">    &#125; A[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A[tot].ls = A[tot].rs = A[tot].sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tot = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="built_in">newNode</span>();</span><br><span class="line">        A[rt] = A[u];</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            A[rt].sum++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (p &lt;= m) A[rt].ls = <span class="built_in">insert</span>(A[u].ls, l, m, p);</span><br><span class="line">            <span class="keyword">else</span> A[rt].rs = <span class="built_in">insert</span>(A[u].rs, m + <span class="number">1</span>, r, p);</span><br><span class="line">            A[rt].sum = A[A[rt].ls].sum + A[A[rt].rs].sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) <span class="keyword">return</span> A[v].sum - A[u].sum;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= m) sum += <span class="built_in">query</span>(A[u].ls, A[v].ls, l, m, a, b);</span><br><span class="line">        <span class="keyword">if</span> (m &lt; b) sum += <span class="built_in">query</span>(A[u].rs, A[v].rs, m + <span class="number">1</span>, r, a, b);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Rt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    Nxt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">1</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) j = Nxt[j];</span><br><span class="line">        <span class="keyword">if</span> (s[j + <span class="number">1</span>] == s[i]) j++;</span><br><span class="line">        Nxt[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    Nxt2[n] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, j = n + <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= n &amp;&amp; s[i] != s[j - <span class="number">1</span>]) j = Nxt2[j];</span><br><span class="line">        <span class="keyword">if</span> (s[j - <span class="number">1</span>] == s[i]) j--;</span><br><span class="line">        Nxt2[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    t1.<span class="built_in">init</span>(n + <span class="number">1</span>); t2.<span class="built_in">init</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        t1.<span class="built_in">addEdge</span>(i, Nxt[i]);</span><br><span class="line">        t2.<span class="built_in">addEdge</span>(i, Nxt2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    t1.<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    t2.<span class="built_in">dfs</span>(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    t3.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        Rt[i] = t3.<span class="built_in">insert</span>(Rt[i - <span class="number">1</span>], <span class="number">1</span>, n + <span class="number">1</span>, t2.Dfn[t1.Nfd[i] + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        y = n - y + <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; t3.<span class="built_in">query</span>(Rt[t1.Dfn[x] - <span class="number">1</span>], Rt[t1.Dfn[x] + t1.Sz[x] - <span class="number">1</span>], <span class="number">1</span>, n + <span class="number">1</span>, t2.Dfn[y], t2.Dfn[y] + t2.Sz[y] - <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> Case;</span><br><span class="line">    cin &gt;&gt; Case;</span><br><span class="line">    <span class="keyword">while</span> (Case--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HDU 多校</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>next树</tag>
      </tags>
  </entry>
  <entry>
    <title>「2021CCPC华为云挑战赛」[HDU 7089] CDN流量调度问题</title>
    <url>/2021/08/22/HDU-7089/</url>
    <content><![CDATA[<h2 id="「题意」"><a href="#「题意」" class="headerlink" title="「题意」"></a>「题意」</h2><p>给定 $n,m$ 和长为 $n$ 的正整数序列 $a,b$，求 $\sum\limits_{i=1}^{n}{\lceil{\frac{a_i}{k_i}}\rceil}$ 的最小值，满足 $1\leq k_i\leq b_i$，且 $\sum{(k_i-1)}\leq m$。</p>
<p>$n\leq 100, m\leq 10000, a_i\leq 10000$</p>
<h3 id="「链接」"><a href="#「链接」" class="headerlink" title="「链接」"></a>「链接」</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7089">7089</a></p>
<h2 id="「分析」"><a href="#「分析」" class="headerlink" title="「分析」"></a>「分析」</h2><p>定义 $f_{i,j}$ 表示对于前 $i$ 个数，$\sum{(k_p-1)}\leq j$ 所得到的 $\sum{\lceil{\frac{a_p}{k_p}}\rceil}$ 的最小值。</p>
<p>显然很多状态是「废」的，因为如果增大 $k_j$ 不会使得 $\lceil{\frac{a_p}{k_p}}\rceil$ 缩小，那么这是没有意义的。</p>
<p>因此有意义的状态就是 $\lceil{\frac{a_p}{k_p}}\rceil$ 有不同取值的最小的 $k_p$，而这样的 $k_p$ 一共只有 $O(\sqrt{a_p})$ 个。</p>
<p>因此可以『整数分块』预处理出 $1\sim 10000$ 对应的所有 $k$，转移时只考虑这些值。</p>
<p>复杂度 $O(nm\sqrt{a_i})$。</p>
<h2 id="「代码」"><a href="#「代码」" class="headerlink" title="「代码」"></a>「代码」</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @date:</span></span><br><span class="line"><span class="comment"> * @source:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> up(i, l, r) for (int i = l; i &lt;= r; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dn(i, l, r) for (int i = l; i &gt;= r; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Trav(i, x) for (auto &amp; i : x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMax</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &gt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMin</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &lt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">vector&lt;pii&gt; Pre[MAXM];</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line"><span class="keyword">int</span> F[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= i; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = i / (i / l);</span><br><span class="line">            Pre[i + <span class="number">1</span>].<span class="built_in">pb</span>(&#123;l, i / l + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Pre[i + <span class="number">1</span>].<span class="built_in">pb</span>(&#123;i + <span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) cin &gt;&gt; A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) cin &gt;&gt; B[i];</span><br><span class="line">    <span class="built_in">memset</span>(F, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> F);</span><br><span class="line">    F[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        F[i][<span class="number">0</span>] = F[i - <span class="number">1</span>][<span class="number">0</span>] + A[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j) &#123;</span><br><span class="line">            <span class="built_in">Trav</span>(x, Pre[A[i]]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.fir &gt; B[i] || j - x.fir + <span class="number">1</span> &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="built_in">chkMin</span>(F[i][j], F[i - <span class="number">1</span>][j - x.fir + <span class="number">1</span>] + x.sec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">chkMin</span>(F[i][j], F[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; F[N][M] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> Case;</span><br><span class="line">    cin &gt;&gt; Case;</span><br><span class="line">    <span class="keyword">while</span> (Case--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HDU的除法极慢，不预处理出每次转移时除法的值，赛后交居然还T了。。</p>
]]></content>
      <categories>
        <category>CCPC华为云挑战赛</category>
      </categories>
      <tags>
        <tag>整数分块</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>2021暑期集训总结</title>
    <url>/2021/08/20/summer-training-summary/</url>
    <content><![CDATA[<p>10场HDU多校，10场牛客多校，5场2020级rating赛，一周五场，一共五周。</p>
<p>我想这个暑假是充实的，每天不是在比赛，就是在改题，又或是在讲课。</p>
<p>我想这个暑假是摸鱼的，每天不是吃烧烤，就是打游戏。预习物理？晚上跑步？嗯，大概干了两三天……</p>
<p>总而言之，我认为我「内心中的摸鱼」&gt;「形式上的忙碌」，用日程上的忙碌掩盖了碌碌无为的实质。</p>
<p>难题不会，学过的东西又时常不会用，等着队友把难题写了，自己写俩签到题就下班。</p>
<p>恍惚间，又回到了高二省选集训的时候。早上暴力打满，就开始想着中午吃什么，再刷会儿知乎、看会儿小说。下午一觉不醒讲题时嬉戏打闹，仿佛讲的题与我无关。我竟想不起那一个多月的集训我究竟学到了什么，除了涨了10斤的体重。</p>
<p>我常说我的OI生涯在NOIP2018后就结束了，往后的日子不过是徒做“挣扎”，甚至都算不上是挣扎。</p>
<p>464分，校内第5，北京市排20名，我“一番盘算”后竟在内心中直接放弃了，认定进队无望。那为什么不退役呐？还要再耗上三四个月的时间……是不舍吗？是期望奇迹吗？还是只是不想学习，给摸鱼找个更好的环境……</p>
<p>我时常在想，要是当时我集训时是在认真学习而非摸鱼，结局会不会有些变化？</p>
<p>直到这次暑假集训结束，我知道没有如果，即使再给我一次机会，我依然会把大把时间挥霍过去。</p>
<p>但这次又真的不一样，与其说是再给一次机会，不如说是新的征程。满打满算，我也不过大二一年的时间，大三会不会继续下去都是个问号。此外，我还有两位队友，我也不再是一个人。每次看到他们补题到一两点，我都感到十分愧疚，为什么我就这么拖后腿呐？……</p>
<p>若是ACM复刻了OI的轨迹与结局，那又何必再续前缘呐……</p>
<p>附</p>
<ul>
<li>HDU多校排名：</li>
</ul>
<p><img src="https://i.loli.net/2021/08/20/cmPFp6yjGxLYOAf.png" alt="image-20210820111002254"></p>
<p>注：第七场由我校命题，故未参加。</p>
<p><img src="https://i.loli.net/2021/08/20/jtxJDM3C1ByceqI.png" alt="image-20210820111106516"></p>
<ul>
<li>牛客排名：</li>
</ul>
<p><img src="https://i.loli.net/2021/08/20/zkmUNSb8iAenYdu.png" alt="image-20210820111308111"></p>
<p><img src="https://i.loli.net/2021/08/20/CaXk6dPLAc59y8G.png"></p>
<p>多说无益，砥砺前行吧……</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/08/25/nowcoder1/</url>
    <content><![CDATA[<h2 id="「NC-Multi-1」A-Alice-and-Bob"><a href="#「NC-Multi-1」A-Alice-and-Bob" class="headerlink" title="「NC Multi 1」A. Alice and Bob"></a>「NC Multi 1」A. Alice and Bob</h2><h2 id="「题意」"><a href="#「题意」" class="headerlink" title="「题意」"></a>「题意」</h2><p>有两堆石子，分别有 $n$ 和 $m$ 个。Alice和Bob轮流操作，每个人每次操作要从某一堆中取走 $x(x&gt;0)$ 个石子，并从另一堆取走 $x\times p(p\geq 0)$ 个石子，无法执行操作的人就输掉了游戏。</p>
<p>两人均采用最优策略，Alice先手，求谁会获胜。</p>
<p>$T\leq 10^4,1\leq n,m\leq 5\times 10^3$</p>
<h2 id="「分析」"><a href="#「分析」" class="headerlink" title="「分析」"></a>「分析」</h2>]]></content>
  </entry>
  <entry>
    <title>「HDU 2021 Multi 10」[HDU 7079] Pty loves lines</title>
    <url>/2021/08/23/HDU-7079/</url>
    <content><![CDATA[<h2 id="「题意」"><a href="#「题意」" class="headerlink" title="「题意」"></a>「题意」</h2><p>求在一个平面上 $n$ 条线（不存在多条线重叠和 $k(k&gt;2)$ 线共点的情况）所有可能的交点个数。</p>
<p>$n\leq 700$</p>
<h3 id="「链接」"><a href="#「链接」" class="headerlink" title="「链接」"></a>「链接」</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7079">7079</a></p>
<h2 id="「分析」"><a href="#「分析」" class="headerlink" title="「分析」"></a>「分析」</h2><p>$f(i,j)$ 表示 $i$ 条线组成 $j$ 个交点的可能性，通过枚举平行线的数量，得到递推式 $f(i,j) |= f(i,j-k\times(i-k))$。</p>
<p>这可以用bitset转移优化，复杂度 $O(\frac{n^4}{w})$。</p>
<p>注意到 $n\leq 700$，打表发现当 $j&gt;35000$ 时，$f(i,j)=1$。因此bitset只需要维护前 $35000$ 位。</p>
<p>复杂度 $O(\frac{n^2\times 35000}{w})$。</p>
<h2 id="「参考代码」"><a href="#「参考代码」" class="headerlink" title="「参考代码」"></a>「参考代码」</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">700</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">40000</span>;</span><br><span class="line"></span><br><span class="line">bitset&lt;MAXM&gt; p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">700</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mx; i++) p[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">2</span>; n &lt;= mx; n++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            p[n] |= p[n - i] &lt;&lt; (i * (n - i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> T, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">int</span> up = n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(up, <span class="number">39999</span>); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[n][j]) v.<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">40000</span>; j &lt;= up; ++j) v.<span class="built_in">push_back</span>(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, v[i], <span class="string">&quot; \n&quot;</span>[i == v.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HDU 多校</category>
      </categories>
      <tags>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title>「2021年北京理工大学2020级暑训 rating4」三角形</title>
    <url>/2021/08/23/nc-18182-F/</url>
    <content><![CDATA[<h2 id="「题意」"><a href="#「题意」" class="headerlink" title="「题意」"></a>「题意」</h2><p>维护一个可重集合，有 $n$ 个操作，为下列三种之一：</p>
<ul>
<li><code>1 x</code>：插入 $x$</li>
<li><code>2 x</code>：删除一个 $x$ （保证集合中至少有 $1$ 个 $x$）</li>
<li><code>3 x</code>：判断集合中是否存在两个数 $a,b$，使得 $a,b,x$ 能够组成三角形的三条边</li>
</ul>
<p>$n\leq 2\times 10^5,x\leq 10^9$</p>
<h2 id="「分析」"><a href="#「分析」" class="headerlink" title="「分析」"></a>「分析」</h2><p>考虑什么情况下 $a,b,x$ 可以组成三角形：当 $a+b&gt;x$ 且 $|a-b|&lt;x$。</p>
<p>当满足 $|a-b|&lt;x$ 时，显然取尽可能大的 $a,b$ 会更可能符合条件。</p>
<p>因此可以维护一棵权值线段树，维护区间内的最大值、最小值和最小差值。</p>
<p>查询时，先查询左区间的最大值和右区间的最小值是否满足条件，然后当满足右区间的最小差值 $&lt;x$ 时，选择继续进入右区间，否则如果左区间的最小差值 $&gt;x$ 时，进入左区间，否则无解。</p>
<p>复杂度 $O(n\log{x})$。</p>
<h2 id="「参考代码」"><a href="#「参考代码」" class="headerlink" title="「参考代码」"></a>「参考代码」</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @date:</span></span><br><span class="line"><span class="comment"> * @source:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> up(i, l, r) for (int i = l; i &lt;= r; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dn(i, l, r) for (int i = l; i &gt;= r; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Trav(i, x) for (auto &amp; i : x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMax</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &gt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMin</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &lt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MX = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = ::MAXN * <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ls, rs, lm, rm, delta, sz;</span><br><span class="line">        <span class="built_in">Node</span> () &#123;</span><br><span class="line">            ls = rs = sz = <span class="number">0</span>;</span><br><span class="line">            lm = delta = INF;</span><br><span class="line">            rm = -INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; A[N];</span><br><span class="line">    <span class="keyword">int</span> rt, tot;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A[tot] = <span class="built_in">Node</span>();</span><br><span class="line">        <span class="keyword">return</span> tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rt = tot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;x = A[rt], &amp;ls = A[A[rt].ls], &amp;rs = A[A[rt].rs];</span><br><span class="line">        x.sz = ls.sz + rs.sz;</span><br><span class="line">        x.lm = <span class="built_in">min</span>(ls.lm, rs.lm);</span><br><span class="line">        x.rm =  <span class="built_in">max</span>(ls.rm, rs.rm);</span><br><span class="line">        x.delta = <span class="built_in">min</span>(ls.delta, rs.delta);</span><br><span class="line">        <span class="keyword">if</span> (ls.sz &amp;&amp; rs.sz) <span class="built_in">chkMin</span>(x.delta, rs.lm - ls.rm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rt) rt = <span class="built_in">newNode</span>();</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            A[rt].sz += num;</span><br><span class="line">            <span class="built_in">assert</span>(A[rt].sz &gt;= <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!A[rt].sz) &#123;</span><br><span class="line">                A[rt] = <span class="built_in">Node</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                A[rt].lm = A[rt].rm = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (A[rt].sz &gt; <span class="number">1</span>) A[rt].delta = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> A[rt].delta = INF;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= m) <span class="built_in">update</span>(A[rt].ls, l, m, p, num);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">update</span>(A[rt].rs, m + <span class="number">1</span>, r, p, num);</span><br><span class="line">        <span class="built_in">pushUp</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rt || A[rt].delta &gt;= x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">2</span> * l &gt; x;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[A[rt].rs].sz &amp;&amp; A[A[rt].ls].sz &amp;&amp; A[A[rt].rs].lm - A[A[rt].ls].rm &lt; x &amp;&amp; A[A[rt].ls].rm + A[A[rt].rs].lm &gt; x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[A[rt].rs].delta &lt; x) <span class="keyword">return</span> <span class="built_in">query</span>(A[rt].rs, m + <span class="number">1</span>, r, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(A[rt].ls, l, m, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Q, opt, x;</span><br><span class="line">    cin &gt;&gt; Q;</span><br><span class="line">    T.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        cin &gt;&gt; opt &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (opt == <span class="number">3</span>) cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= MX);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) T.<span class="built_in">update</span>(T.rt, <span class="number">1</span>, MX, x, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">2</span>) T.<span class="built_in">update</span>(T.rt, <span class="number">1</span>, MX, x, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">3</span>) cout &lt;&lt; (T.<span class="built_in">query</span>(T.rt, <span class="number">1</span>, MX, x) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>rating赛</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>「2021CCPC华为云挑战赛」[HDU 7091] 重叠的子串</title>
    <url>/2021/08/22/HDU-7091/</url>
    <content><![CDATA[<h2 id="「题意」"><a href="#「题意」" class="headerlink" title="「题意」"></a>「题意」</h2><p>给定长为 $n$ 的小写字符串 $s$，有 $m$ 个询问。每次给定 $l,r$，表示子串 $s[l,r]$。判断 $s$ 中是否存在两个或多个出现的有重叠部分的给定子串。</p>
<p>$\sum{n}\leq 6\times10^5,\sum{m}\leq 3\times 10^6$</p>
<h3 id="「链接」"><a href="#「链接」" class="headerlink" title="「链接」"></a>「链接」</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7091">7091</a></p>
<h2 id="「分析」"><a href="#「分析」" class="headerlink" title="「分析」"></a>「分析」</h2><p>查询「是否存在两个或多个出现的有重叠部分的子串」是个经典问题，类似的有「查询有多少个本质不同的多次出现的有重叠部分的子串」。</p>
<p>具体来说，对于子串 $t$，若它对应的Rpos集合中，存在两项，它们的间距小于 $|t|$，即说明 $s$ 中有两个 $t$ 且存在重叠。</p>
<p>子串 $s[l,r]$ 应该属于叶子节点 $s[1,r]$ 的某个祖先节点，查询它可以在Fail树上倍增，用 $O(n\log{n})\sim O(\log{n})$ 的复杂度解决。</p>
<p>而每个节点对应的Rpos集合可以通过线段树合并的方式，自叶子节点向上传递信息，合并时维护Rpos中相距最近的两项的间距，复杂度 $O(n\log{n})$。</p>
<p>查询时，比较 $s[l,r]$ 对应的Fail树上的节点对应的线段树上的节点所维护的Rpos里间距最小的相邻两项的间距和 $r-l+1$ 即可得到答案。</p>
<p>复杂度 $O((n+q)\log{n})$。</p>
<p>标算给的是启发式合并，$O(n\log^2{n})$ 有点逊……</p>
<h2 id="「参考代码」"><a href="#「参考代码」" class="headerlink" title="「参考代码」"></a>「参考代码」</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @date:</span></span><br><span class="line"><span class="comment"> * @source:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> up(i, l, r) for (int i = l; i &lt;= r; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dn(i, l, r) for (int i = l; i &gt;= r; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Trav(i, x) for (auto &amp; i : x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMax</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &gt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMin</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &lt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = ::MAXN * <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ls, rs, lm, rm, val;</span><br><span class="line">    &#125; A[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;a = A[tot];</span><br><span class="line">        a.ls = a.rs = <span class="number">0</span>;</span><br><span class="line">        a.lm = INF, a.rm = -INF;</span><br><span class="line">        a.val = INF;</span><br><span class="line">        <span class="keyword">return</span> tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;x = A[rt], &amp;ls = A[A[rt].ls], &amp;rs = A[A[rt].rs];</span><br><span class="line">        <span class="built_in">chkMin</span>(x.lm, <span class="built_in">min</span>(ls.lm, rs.lm));</span><br><span class="line">        <span class="built_in">chkMax</span>(x.rm, <span class="built_in">max</span>(ls.rm, rs.rm));</span><br><span class="line">        <span class="built_in">chkMin</span>(x.val, <span class="built_in">min</span>(ls.val, rs.val));</span><br><span class="line">        <span class="built_in">chkMin</span>(x.val, rs.lm - ls.rm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rt) rt = <span class="built_in">newNode</span>();</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            A[rt].lm = A[rt].rm = p;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= m) <span class="built_in">update</span>(A[rt].ls, l, m, p);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">update</span>(A[rt].rs, m + <span class="number">1</span>, r, p);</span><br><span class="line">        <span class="built_in">pushUp</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u || !v) <span class="keyword">return</span> u + v;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">newNode</span>();</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            A[x].lm = A[x].rm = l;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        A[x].ls = <span class="built_in">merge</span>(A[u].ls, A[v].ls, l, m);</span><br><span class="line">        A[x].rs = <span class="built_in">merge</span>(A[u].rs, A[v].rs, m + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushUp</span>(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = ::MAXN &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> LOG = <span class="number">23</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> len, ch[M], fail;</span><br><span class="line">    &#125; A[N];</span><br><span class="line">    <span class="keyword">int</span> rt, tot, lst, n;</span><br><span class="line">    <span class="keyword">int</span> Rpos[N], Rt[N], Pos[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;a = A[tot];</span><br><span class="line">        a.len = a.fail = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a.ch, <span class="number">0</span>, <span class="keyword">sizeof</span> a.ch);</span><br><span class="line">        <span class="keyword">return</span> tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="built_in">newNode</span>(), p = lst;</span><br><span class="line">        A[cur].len = A[p].len + <span class="number">1</span>;</span><br><span class="line">        Rpos[cur] = A[cur].len;</span><br><span class="line">        Pos[Rpos[cur]] = cur;</span><br><span class="line">        T.<span class="built_in">update</span>(Rt[cur], <span class="number">1</span>, n, Rpos[cur]);</span><br><span class="line">        <span class="keyword">for</span> (; p &amp;&amp; !A[p].ch[c]; p = A[p].fail) A[p].ch[c] = cur;</span><br><span class="line">        <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">            A[cur].fail = rt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = A[p].ch[c];</span><br><span class="line">            <span class="keyword">if</span> (A[q].len == A[p].len + <span class="number">1</span>) &#123;</span><br><span class="line">                A[cur].fail = q;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> clone = <span class="built_in">newNode</span>();</span><br><span class="line">                A[clone] = A[q];</span><br><span class="line">                A[clone].len = A[p].len + <span class="number">1</span>;</span><br><span class="line">                A[cur].fail = A[q].fail = clone;</span><br><span class="line">                Rpos[clone] = Rpos[q];</span><br><span class="line">                <span class="keyword">for</span> (; p &amp;&amp; A[p].ch[c] == q; p = A[p].fail) A[p].ch[c] = clone;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lst = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Fa[N][LOG];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> a[N], b[N];</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; ++i) ++a[A[i].len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tot - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) b[a[A[i].len]--] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tot - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            Rt[A[b[i]].fail] = T.<span class="built_in">merge</span>(Rt[b[i]], Rt[A[b[i]].fail], <span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; ++i) Fa[i][<span class="number">0</span>] = A[i].fail;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; LOG; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; ++i) &#123;</span><br><span class="line">                Fa[i][j] = Fa[Fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">        tot = <span class="number">1</span>;</span><br><span class="line">        rt = lst = <span class="built_in">newNode</span>();</span><br><span class="line">        <span class="built_in">memset</span>(Rt, <span class="number">0</span>, <span class="keyword">sizeof</span> Rt);</span><br><span class="line">        T.<span class="built_in">init</span>();</span><br><span class="line">        n = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">push_back</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">sort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = Pos[r], len = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = LOG - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[Fa[p][i]].len &gt;= len) p = Fa[p][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T.A[Rt[p]].val &lt; len) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; sam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;m, s);</span><br><span class="line">    sam.<span class="built_in">build</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        sam.<span class="built_in">solve</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Case;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Case);</span><br><span class="line">    <span class="keyword">while</span> (Case--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CCPC华为云挑战赛</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>倍增</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
</search>
