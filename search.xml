<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「HDU 2021 Multi 9」[HDU 7073] Integers Have Friends 2.0</title>
    <url>/2021/08/20/HDU-7073/</url>
    <content><![CDATA[<h2 id="「题意」"><a href="#「题意」" class="headerlink" title="「题意」"></a>「题意」</h2><p>给定一个由 $n$ 个不同正整数组成的数组 $a$，选择一个最长子序列 $a_{c_1},\cdots,a_{c_p}$，使得存在某个正整数 $m$，满足 $a_{c_1}\bmod m=a_{c_2}\bmod m\cdots=a_{c_p}\bmod m$。</p>
<p>$a_i\leq 4\times10^{12},\sum{n}\leq 10^6$</p>
<h3 id="「链接」"><a href="#「链接」" class="headerlink" title="「链接」"></a>「链接」</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7073">7073</a></p>
<h2 id="「分析」"><a href="#「分析」" class="headerlink" title="「分析」"></a>「分析」</h2><p>成功被出题人带到CF1648B（同问题求最长子区间）的坑里去了，总想着要找到同余系的话就要满足任意两个数的差都有大于 $1$ 的公因数，于是就不停在想对这 $n^2$ 对差怎么搞。。。</p>
<p>实际上，答案一定大于 $\lfloor\frac{n}{2}\rfloor$。因为当 $m$ 取 $2$ 时，奇数或偶数肯定有一个会超过一半。</p>
<p>那么，随机选择两个数 $a_x$ 和 $a_y$，他们有超过 $\frac{1}{4}$ 的概率同属于最大的同余系。若想找到与它同属一个同余系的其他数，只需要分别求出 $b_i=|a_i-a_x|$ ，然后判断 $b_i$ 是否存在大于 $1$ 的公因数即可。具体来说，就是对 $|a_x-a_y|$ 分解质因数，然后依次判断 $b_i$ 是否是该质因数的倍数。由于在 $a_i\leq 4\times10^{12}$ 的范围内至多出现 $11$ 个质因数，因此跑一次复杂度为 $O(11n\sqrt{a_i})$。</p>
<p>随机选择 $k$ 次 $(x,y)$，就有$1-\frac{1}{4^k}$ 的概率找到最大的同余系，取 $k=40$ 即可。</p>
<h2 id="「参考代码」"><a href="#「参考代码」" class="headerlink" title="「参考代码」"></a>「参考代码」</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @date:2021-08-17 16:18:59</span></span><br><span class="line"><span class="comment"> * @source:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> up(i, l, r) for (int i = l; i &lt;= r; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dn(i, l, r) for (int i = l; i &gt;= r; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Trav(i, x) for (auto &amp; i : x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMax</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &gt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMin</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &lt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">ll v[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PRIMERANGE = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">bitset&lt;PRIMERANGE&gt; isnPri;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; Prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isnPri[i]) Prime.<span class="built_in">pb</span>(i);</span><br><span class="line">        <span class="built_in">Trav</span>(p, Prime) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = p * i;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            isnPri[x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">divide</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    vector&lt;ll&gt; vs;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = -x;</span><br><span class="line">    <span class="built_in">Trav</span>(p, Prime) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p * p &gt; x) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (x % p == <span class="number">0</span>) &#123;</span><br><span class="line">            vs.<span class="built_in">pb</span>(p);</span><br><span class="line">            <span class="keyword">while</span> (x % p == <span class="number">0</span>) x /= p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) vs.<span class="built_in">pb</span>(x);</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">rand</span>() % N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            B[j] = <span class="built_in">abs</span>(v[a] - v[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;ll&gt; v1 = <span class="built_in">divide</span>(B[a + <span class="built_in">rand</span>() % (N - a)]);</span><br><span class="line">        <span class="built_in">Trav</span>(x, v1) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (B[j] % x == <span class="number">0</span>) ++num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">chkMax</span>(ans, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="number">19260817</span>);</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">Euler</span>(<span class="number">2e6</span>);</span><br><span class="line">    <span class="keyword">int</span> Case;</span><br><span class="line">    cin &gt;&gt; Case;</span><br><span class="line">    <span class="keyword">while</span> (Case--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HDU 多校</category>
      </categories>
      <tags>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>「HDU 2021 Multi 10」[HDU 7074] Pty loves string</title>
    <url>/2021/08/22/HDU-7084/</url>
    <content><![CDATA[<h2 id="「题意」"><a href="#「题意」" class="headerlink" title="「题意」"></a>「题意」</h2><p>给定长为 $n$ 的字符串 $s[1\cdots n]$，有 $m$ 个询问。每次给定 $x,y$，查询由 $s[1,x]$ 和 $s[n-y+1,n]$ 拼接而成的字符串在 $s$ 中的出现次数。</p>
<p>$T\leq 5,n,m\leq 2\times 10^5$</p>
<h3 id="「链接」"><a href="#「链接」" class="headerlink" title="「链接」"></a>「链接」</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7084">7084</a></p>
<h2 id="「分析」"><a href="#「分析」" class="headerlink" title="「分析」"></a>「分析」</h2><p>对于一个出现位置 $s[l,r]$ ，满足 $S[l,l + x − 1]$ 和 $s[1,x]$ 相等， $s[r − y + 1,r]$ 和 $s[n − y + 1,n]$ 相等，且 $l+x-1+1=r-y+1$。</p>
<p>对于 $s[1,l+x-1]$ 来说，这两个相等的部分就是前后缀，这能联想到border。</p>
<p>用KMP预处理，通过跳next，$s[l+x-1]$ 能跳到 $s[x]$。从后往前跑KMP，反着建next，$s[r-y+1]$ 能跳到 $s[n-y+1]$。</p>
<p>因此可以建成一棵next树，$i$ 与 $next[i]$ 连边，那么符合条件的便是 $x$ 子树的所有节点。</p>
<p>而由于 $l+x=r-y+1$，因此若两棵子树上的两个点编号差为 $1$，则它们对应的 $[l,r]$ 便是一个出现位置。</p>
<p>问题转化为正反两棵next树，查询在正next树中 $x$ 的子树与反next树中 $n-y+1$ 的子树中，节点编号差为 $1$ 的点对数量。</p>
<p>这可以转化为二维数点问题。</p>
<p>具体来说，对两棵树求DFS序，并将第一棵树的DFS序映射到第二棵树上。问题便转化成求在 $[Dfn[y],Dfn[y]+Sz[y]-1]$ 的区间中，权值为 $[Dfn[x],Dfn[x]+Sz[x]-1]$ 的点个数。</p>
<p>这可以用主席树解决。</p>
<p>复杂度 $O(m\log{n})$。</p>
<h2 id="「参考代码」"><a href="#「参考代码」" class="headerlink" title="「参考代码」"></a>「参考代码」</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @date:</span></span><br><span class="line"><span class="comment"> * @source:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> up(i, l, r) for (int i = l; i &lt;= r; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dn(i, l, r) for (int i = l; i &gt;= r; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Trav(i, x) for (auto &amp; i : x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMax</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &gt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMin</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &lt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> Nxt[N], Nxt2[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = ::N;</span><br><span class="line">    vi G[N];</span><br><span class="line">    <span class="keyword">int</span> Dfn[N], Nfd[N], Sz[N], tot;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        Dfn[x] = ++tot;</span><br><span class="line">        Nfd[tot] = x;</span><br><span class="line">        Sz[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">Trav</span>(v, G[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(v, x);</span><br><span class="line">            Sz[x] += Sz[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t1, t2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PresidentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = ::N * <span class="number">40</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ls, rs, sum;</span><br><span class="line">    &#125; A[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A[tot].ls = A[tot].rs = A[tot].sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tot = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="built_in">newNode</span>();</span><br><span class="line">        A[rt] = A[u];</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            A[rt].sum++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (p &lt;= m) A[rt].ls = <span class="built_in">insert</span>(A[u].ls, l, m, p);</span><br><span class="line">            <span class="keyword">else</span> A[rt].rs = <span class="built_in">insert</span>(A[u].rs, m + <span class="number">1</span>, r, p);</span><br><span class="line">            A[rt].sum = A[A[rt].ls].sum + A[A[rt].rs].sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) <span class="keyword">return</span> A[v].sum - A[u].sum;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= m) sum += <span class="built_in">query</span>(A[u].ls, A[v].ls, l, m, a, b);</span><br><span class="line">        <span class="keyword">if</span> (m &lt; b) sum += <span class="built_in">query</span>(A[u].rs, A[v].rs, m + <span class="number">1</span>, r, a, b);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Rt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    Nxt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">1</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) j = Nxt[j];</span><br><span class="line">        <span class="keyword">if</span> (s[j + <span class="number">1</span>] == s[i]) j++;</span><br><span class="line">        Nxt[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    Nxt2[n] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, j = n + <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= n &amp;&amp; s[i] != s[j - <span class="number">1</span>]) j = Nxt2[j];</span><br><span class="line">        <span class="keyword">if</span> (s[j - <span class="number">1</span>] == s[i]) j--;</span><br><span class="line">        Nxt2[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    t1.<span class="built_in">init</span>(n + <span class="number">1</span>); t2.<span class="built_in">init</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        t1.<span class="built_in">addEdge</span>(i, Nxt[i]);</span><br><span class="line">        t2.<span class="built_in">addEdge</span>(i, Nxt2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    t1.<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    t2.<span class="built_in">dfs</span>(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    t3.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        Rt[i] = t3.<span class="built_in">insert</span>(Rt[i - <span class="number">1</span>], <span class="number">1</span>, n + <span class="number">1</span>, t2.Dfn[t1.Nfd[i] + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        y = n - y + <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; t3.<span class="built_in">query</span>(Rt[t1.Dfn[x] - <span class="number">1</span>], Rt[t1.Dfn[x] + t1.Sz[x] - <span class="number">1</span>], <span class="number">1</span>, n + <span class="number">1</span>, t2.Dfn[y], t2.Dfn[y] + t2.Sz[y] - <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> Case;</span><br><span class="line">    cin &gt;&gt; Case;</span><br><span class="line">    <span class="keyword">while</span> (Case--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HDU 多校</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>next树</tag>
      </tags>
  </entry>
  <entry>
    <title>2021暑期集训总结</title>
    <url>/2021/08/20/summer-training-summary/</url>
    <content><![CDATA[<p>10场HDU多校，10场牛客多校，5场2020级rating赛，一周五场，一共五周。</p>
<p>我想这个暑假是充实的，每天不是在比赛，就是在改题，又或是在讲课。</p>
<p>我想这个暑假是摸鱼的，每天不是吃烧烤，就是打游戏。预习物理？晚上跑步？嗯，大概干了两三天……</p>
<p>总而言之，我认为我「内心中的摸鱼」&gt;「形式上的忙碌」，用日程上的忙碌掩盖了碌碌无为的实质。</p>
<p>难题不会，学过的东西又时常不会用，等着队友把难题写了，自己写俩签到题就下班。</p>
<p>恍惚间，又回到了高二省选集训的时候。早上暴力打满，就开始想着中午吃什么，再刷会儿知乎、看会儿小说。下午一觉不醒讲题时嬉戏打闹，仿佛讲的题与我无关。我竟想不起那一个多月的集训我究竟学到了什么，除了涨了10斤的体重。</p>
<p>我常说我的OI生涯在NOIP2018后就结束了，往后的日子不过是徒做“挣扎”，甚至都算不上是挣扎。</p>
<p>464分，校内第5，北京市排20名，我“一番盘算”后竟在内心中直接放弃了，认定进队无望。那为什么不退役呐？还要再耗上三四个月的时间……是不舍吗？是期望奇迹吗？还是只是不想学习，给摸鱼找个更好的环境……</p>
<p>我时常在想，要是当时我集训时是在认真学习而非摸鱼，结局会不会有些变化？</p>
<p>直到这次暑假集训结束，我知道没有如果，即使再给我一次机会，我依然会把大把时间挥霍过去。</p>
<p>但这次又真的不一样，与其说是再给一次机会，不如说是新的征程。满打满算，我也不过大二一年的时间，大三会不会继续下去都是个问号。此外，我还有两位队友，我也不再是一个人。每次看到他们补题到一两点，我都感到十分愧疚，为什么我就这么拖后腿呐？……</p>
<p>若是ACM复刻了OI的轨迹与结局，那又何必再续前缘呐……</p>
<p>附</p>
<ul>
<li>HDU多校排名：</li>
</ul>
<p><img src="https://i.loli.net/2021/08/20/cmPFp6yjGxLYOAf.png" alt="image-20210820111002254"></p>
<p>注：第七场由我校命题，故未参加。</p>
<p><img src="https://i.loli.net/2021/08/20/jtxJDM3C1ByceqI.png" alt="image-20210820111106516"></p>
<ul>
<li>牛客排名：</li>
</ul>
<p><img src="https://i.loli.net/2021/08/20/zkmUNSb8iAenYdu.png" alt="image-20210820111308111"></p>
<p><img src="https://i.loli.net/2021/08/20/CaXk6dPLAc59y8G.png"></p>
<p>多说无益，砥砺前行吧……</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>「2021CCPC华为云挑战赛」[HDU 7089] CDN流量调度问题</title>
    <url>/2021/08/22/HDU-7089/</url>
    <content><![CDATA[<h2 id="「题意」"><a href="#「题意」" class="headerlink" title="「题意」"></a>「题意」</h2><p>给定 $n,m$ 和长为 $n$ 的正整数序列 $a,b$，求 $\sum\limits_{i=1}^{n}{\lceil{\frac{a_i}{k_i}}\rceil}$ 的最小值，满足 $1\leq k_i\leq b_i$，且 $\sum{(k_i-1)}\leq m$。</p>
<p>$n\leq 100, m\leq 10000, a_i\leq 10000$</p>
<h3 id="「链接」"><a href="#「链接」" class="headerlink" title="「链接」"></a>「链接」</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7089">7089</a></p>
<h2 id="「分析」"><a href="#「分析」" class="headerlink" title="「分析」"></a>「分析」</h2><p>定义 $f_{i,j}$ 表示对于前 $i$ 个数，$\sum{(k_p-1)}\leq j$ 所得到的 $\sum{\lceil{\frac{a_p}{k_p}}\rceil}$ 的最小值。</p>
<p>显然很多状态是「废」的，因为如果增大 $k_j$ 不会使得 $\lceil{\frac{a_p}{k_p}}\rceil$ 缩小，那么这是没有意义的。</p>
<p>因此有意义的状态就是 $\lceil{\frac{a_p}{k_p}}\rceil$ 有不同取值的最小的 $k_p$，而这样的 $k_p$ 一共只有 $O(\sqrt{a_p})$ 个。</p>
<p>因此可以『整数分块』预处理出 $1\sim 10000$ 对应的所有 $k$，转移时只考虑这些值。</p>
<p>复杂度 $O(nm\sqrt{a_i})$。</p>
<h2 id="「代码」"><a href="#「代码」" class="headerlink" title="「代码」"></a>「代码」</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @date:</span></span><br><span class="line"><span class="comment"> * @source:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> up(i, l, r) for (int i = l; i &lt;= r; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dn(i, l, r) for (int i = l; i &gt;= r; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Trav(i, x) for (auto &amp; i : x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMax</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &gt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMin</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &lt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line">vector&lt;pii&gt; Pre[MAXM];</span><br><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN];</span><br><span class="line"><span class="keyword">int</span> F[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= i; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = i / (i / l);</span><br><span class="line">            Pre[i + <span class="number">1</span>].<span class="built_in">pb</span>(&#123;l, i / l + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Pre[i + <span class="number">1</span>].<span class="built_in">pb</span>(&#123;i + <span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) cin &gt;&gt; A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) cin &gt;&gt; B[i];</span><br><span class="line">    <span class="built_in">memset</span>(F, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> F);</span><br><span class="line">    F[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        F[i][<span class="number">0</span>] = F[i - <span class="number">1</span>][<span class="number">0</span>] + A[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j) &#123;</span><br><span class="line">            <span class="built_in">Trav</span>(x, Pre[A[i]]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.fir &gt; B[i] || j - x.fir + <span class="number">1</span> &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="built_in">chkMin</span>(F[i][j], F[i - <span class="number">1</span>][j - x.fir + <span class="number">1</span>] + x.sec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">chkMin</span>(F[i][j], F[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; F[N][M] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> Case;</span><br><span class="line">    cin &gt;&gt; Case;</span><br><span class="line">    <span class="keyword">while</span> (Case--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HDU的除法极慢，不预处理出每次转移时除法的值，赛后交居然还T了。。</p>
]]></content>
      <categories>
        <category>CCPC华为云挑战赛</category>
      </categories>
      <tags>
        <tag>整数分块</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「2021CCPC华为云挑战赛」[HDU 7091] 重叠的子串</title>
    <url>/2021/08/22/HDU-7091/</url>
    <content><![CDATA[<h2 id="「题意」"><a href="#「题意」" class="headerlink" title="「题意」"></a>「题意」</h2><p>给定长为 $n$ 的小写字符串 $s$，有 $m$ 个询问。每次给定 $l,r$，表示子串 $s[l,r]$。判断 $s$ 中是否存在两个或多个出现的有重叠部分的给定子串。</p>
<p>$\sum{n}\leq 6\times10^5,\sum{m}\leq 3\times 10^6$</p>
<h3 id="「链接」"><a href="#「链接」" class="headerlink" title="「链接」"></a>「链接」</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7091">7091</a></p>
<h2 id="「分析」"><a href="#「分析」" class="headerlink" title="「分析」"></a>「分析」</h2><p>查询「是否存在两个或多个出现的有重叠部分的子串」是个经典问题，类似的有「查询有多少个本质不同的多次出现的有重叠部分的子串」。</p>
<p>具体来说，对于子串 $t$，若它对应的Rpos集合中，存在两项，它们的间距小于 $|t|$，即说明 $s$ 中有两个 $t$ 且存在重叠。</p>
<p>子串 $s[l,r]$ 应该属于叶子节点 $s[1,r]$ 的某个祖先节点，查询它可以在Fail树上倍增，用 $O(n\log{n})\sim O(\log{n})$ 的复杂度解决。</p>
<p>而每个节点对应的Rpos集合可以通过线段树合并的方式，自叶子节点向上传递信息，合并时维护Rpos中相距最近的两项的间距，复杂度 $O(n\log{n})$。</p>
<p>查询时，比较 $s[l,r]$ 对应的Fail树上的节点对应的线段树上的节点所维护的Rpos里间距最小的相邻两项的间距和 $r-l+1$ 即可得到答案。</p>
<p>复杂度 $O((n+q)\log{n})$。</p>
<p>标算给的是启发式合并，$O(n\log^2{n})$ 有点逊……</p>
<h2 id="「参考代码」"><a href="#「参考代码」" class="headerlink" title="「参考代码」"></a>「参考代码」</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @date:</span></span><br><span class="line"><span class="comment"> * @source:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) (int)x.size()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> up(i, l, r) for (int i = l; i &lt;= r; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dn(i, l, r) for (int i = l; i &gt;= r; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Trav(i, x) for (auto &amp; i : x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMax</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &gt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class G&gt; <span class="keyword">bool</span> <span class="title">chkMin</span><span class="params">(T &amp;x, G y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y &lt; x ? x = y, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = ::MAXN * <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ls, rs, lm, rm, val;</span><br><span class="line">    &#125; A[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;a = A[tot];</span><br><span class="line">        a.ls = a.rs = <span class="number">0</span>;</span><br><span class="line">        a.lm = INF, a.rm = -INF;</span><br><span class="line">        a.val = INF;</span><br><span class="line">        <span class="keyword">return</span> tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">newNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;x = A[rt], &amp;ls = A[A[rt].ls], &amp;rs = A[A[rt].rs];</span><br><span class="line">        <span class="built_in">chkMin</span>(x.lm, <span class="built_in">min</span>(ls.lm, rs.lm));</span><br><span class="line">        <span class="built_in">chkMax</span>(x.rm, <span class="built_in">max</span>(ls.rm, rs.rm));</span><br><span class="line">        <span class="built_in">chkMin</span>(x.val, <span class="built_in">min</span>(ls.val, rs.val));</span><br><span class="line">        <span class="built_in">chkMin</span>(x.val, rs.lm - ls.rm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rt) rt = <span class="built_in">newNode</span>();</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            A[rt].lm = A[rt].rm = p;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= m) <span class="built_in">update</span>(A[rt].ls, l, m, p);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">update</span>(A[rt].rs, m + <span class="number">1</span>, r, p);</span><br><span class="line">        <span class="built_in">pushUp</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u || !v) <span class="keyword">return</span> u + v;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">newNode</span>();</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            A[x].lm = A[x].rm = l;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        A[x].ls = <span class="built_in">merge</span>(A[u].ls, A[v].ls, l, m);</span><br><span class="line">        A[x].rs = <span class="built_in">merge</span>(A[u].rs, A[v].rs, m + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushUp</span>(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = ::MAXN &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> LOG = <span class="number">23</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> len, ch[M], fail;</span><br><span class="line">    &#125; A[N];</span><br><span class="line">    <span class="keyword">int</span> rt, tot, lst, n;</span><br><span class="line">    <span class="keyword">int</span> Rpos[N], Rt[N], Pos[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;a = A[tot];</span><br><span class="line">        a.len = a.fail = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a.ch, <span class="number">0</span>, <span class="keyword">sizeof</span> a.ch);</span><br><span class="line">        <span class="keyword">return</span> tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="built_in">newNode</span>(), p = lst;</span><br><span class="line">        A[cur].len = A[p].len + <span class="number">1</span>;</span><br><span class="line">        Rpos[cur] = A[cur].len;</span><br><span class="line">        Pos[Rpos[cur]] = cur;</span><br><span class="line">        T.<span class="built_in">update</span>(Rt[cur], <span class="number">1</span>, n, Rpos[cur]);</span><br><span class="line">        <span class="keyword">for</span> (; p &amp;&amp; !A[p].ch[c]; p = A[p].fail) A[p].ch[c] = cur;</span><br><span class="line">        <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">            A[cur].fail = rt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = A[p].ch[c];</span><br><span class="line">            <span class="keyword">if</span> (A[q].len == A[p].len + <span class="number">1</span>) &#123;</span><br><span class="line">                A[cur].fail = q;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> clone = <span class="built_in">newNode</span>();</span><br><span class="line">                A[clone] = A[q];</span><br><span class="line">                A[clone].len = A[p].len + <span class="number">1</span>;</span><br><span class="line">                A[cur].fail = A[q].fail = clone;</span><br><span class="line">                Rpos[clone] = Rpos[q];</span><br><span class="line">                <span class="keyword">for</span> (; p &amp;&amp; A[p].ch[c] == q; p = A[p].fail) A[p].ch[c] = clone;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lst = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Fa[N][LOG];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> a[N], b[N];</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; ++i) ++a[A[i].len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tot - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) b[a[A[i].len]--] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tot - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            Rt[A[b[i]].fail] = T.<span class="built_in">merge</span>(Rt[b[i]], Rt[A[b[i]].fail], <span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; ++i) Fa[i][<span class="number">0</span>] = A[i].fail;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; LOG; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; ++i) &#123;</span><br><span class="line">                Fa[i][j] = Fa[Fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">        tot = <span class="number">1</span>;</span><br><span class="line">        rt = lst = <span class="built_in">newNode</span>();</span><br><span class="line">        <span class="built_in">memset</span>(Rt, <span class="number">0</span>, <span class="keyword">sizeof</span> Rt);</span><br><span class="line">        T.<span class="built_in">init</span>();</span><br><span class="line">        n = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">push_back</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">sort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = Pos[r], len = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = LOG - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[Fa[p][i]].len &gt;= len) p = Fa[p][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T.A[Rt[p]].val &lt; len) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; sam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;m, s);</span><br><span class="line">    sam.<span class="built_in">build</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        sam.<span class="built_in">solve</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Case;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Case);</span><br><span class="line">    <span class="keyword">while</span> (Case--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CCPC华为云挑战赛</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>倍增</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
</search>
